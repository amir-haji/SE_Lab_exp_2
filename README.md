به نام خدا
# آزمایشگاه مهندسی نرم‌افزار - آزمایش دوم

اعضای گروه:

امیرحسین حاجی محمد رضایی - ۹۹۱۰۹۲۵۲

علی رازقندی - ۹۹۱۰۹۲۹۶

سید رضا قمقام - ۹۹۱۷۰۵۴۲


# آشنایی با اصول شئ‌گرایی (موسوم به اصول SOLID)

## اهداف
در این آزمایش هدف بر آن است که دانشجویان با به کارگیری اصول SOLID در یک پروژه‌ی عملی ساده آشنا شوند.

## نیازمندی‌ها
آشنایی اولیه با مفاهیم برنامه نویسی و طراحی شی‌گرا که دانشجویان قبلاً در درس برنامه‌سازی پیشرفته با آن آشنا شده‌اند.

## ابزارهای مورد استفاده
- یک Java IDE مانند IntelliJ IDEA و یا Eclipse به همراه jdk حداقل نسخه ۸ 

## منابع آموزشی
برای آشنایی با این اصول و آشنایی با منابع مناسب به [اینجا](https://github.com/ssc-public/Software-Engineering-Lab/blob/main/educational-resources/SOLID/README.md) مراجعه کنید.

## مقدمه
در این آزمایش شما خواهید آموخت که چگونه می‌توانید با به کارگیری اصول SOLID، نرم‌افزارهایی را بسازید که از نظر قابلیت نگهداری و بهبود، در وضعیت مطلوبی باشند و مدیریت تغییرات در آن‌ها به آسانی میسر باشد (شک نکنید که به کارگیری این اصول اساسی و بسیاری دیگر از اصول مهندسی نرم افزار، باعث تفاوت شما با سایر همکارانتان خواهد شد)

## بخش اول: توضیحاتی پیرامون برنامه‌ی داده شده
می‌توانید برنامه را از [اینجا](https://github.com/ssc-public/Software-Engineering-Lab/tree/main/base-projects/SOLID-Principles) بارگیری کنید.

### مفروضات مسئله
صورت آزمایش در درس افزار بارگزاری شده است و می‌توانید برای تحویل گزارش (با در نظر گرفتن ملاحظات گفته شده) از قالب های زیر استفاده کنید.

## بخش دوم: دستور آزمایش

### گام ۱: افزودن یک روش پیام رسانی دیگر

	تغییراتی را که در کد فعلی برنامه می‌دهید، در جدول زیر ثبت کنید و در نهایت تعداد کل تغییرات را اعلان کنید.
    - توجه: مواردی که به عنوان تغییرات باید اعلان شود شامل این موارد هستند:
      1. ساخت کلاس جدید
      2. افزودن تابع جدید به کلاس و یا واسط (برای توابع جدید صرفا اعلام تغییر کنید)
      3. هر خطوط پیاپی‌ای که در تابع main و برای افزودن یک قابلیت جدید اضافه می‌کنید. به عنوان مثال اگر سه خط را به منظور تشخیص نوع پیام اضافه می‌کنید، آن سه خط را در قالب یک تغییر اعلام کنید (البته جزییات آن را در ستون «شرحی کوتاه از تغییر» توضیح دهید).

<table dir='rtl'>
<tbody>
<tr>
<td width="64">
<p><strong>ردیف</strong></p>
</td>
<td width="198">
<p><strong>محل اعمال تغییرات (کلاس/واسط)</strong></p>
</td>
<td width="141">
<p><strong>عنوان تغییر</strong></p>
</td>
<td width="292">
<p><strong>شرحی کوتاه از تغییر</strong></p>
</td>
</tr>
<tr>
<td width="64">
<p><strong>۱</strong></p>
</td>
<td width="198">
<p>PaymentService</p>
</td>
<td width="141">
<p>افزودن سفارش با موبایل</p>
</td>
<td width="292">
<p>یک کلاس با عنوان PhoneOrderService به بخش PaymentService اضافه شد</p>
</td>
</tr>

<tr>
<td width="64">
<p><strong>۲</strong></p>
</td>
<td width="198">
<p>OrderService</p>
</td>
<td width="141">
<p>افزودن واسط ورود با موبایل</p>
</td>
<td width="292">
<p>به واسط OrderService تابع phoneOrderRegister جهت ورود برای پرداخت با موبایل اضافه گردید</p>
</td>
</tr>

<tr>
<td width="64">
<p><strong>۳</strong></p>
</td>
<td width="198">
<p>OrderService</p>
</td>
<td width="141">
<p>افزودن واسط پرداخت با موبایل</p>
</td>
<td width="292">
<p>به واسط OrderService تابع phoneOrderPayment جهت پرداخت با موبایل اضافه گردید</p>
</td>
</tr>

<tr>
<td width="64">
<p><strong>۴</strong></p>
</td>
<td width="198">
<p>OnlineOrderService</p>
</td>
<td width="141">
<p>افزودن واسط ورود با موبایل</p>
</td>
<td width="292">
<p>به کلاس OnlineOrderService تابع phoneOrderRegister جهت ورود با موبایل اضافه گردید</p>
</td>
</tr>

<tr>
<td width="64">
<p><strong>۵</strong></p>
</td>
<td width="198">
<p>OnlineOrderService</p>
</td>
<td width="141">
<p>افزودن واسط پرداخت با موبایل</p>
</td>
<td width="292">
<p>به کلاس OnlineOrderService تابع phoneOrderPayment جهت پرداخت با موبایل اضافه گردید</p>
</td>
</tr>

<tr>
<td width="64">
<p><strong>۶</strong></p>
</td>
<td width="198">
<p>OnSiteOrderService</p>
</td>
<td width="141">
<p>افزودن واسط ورود با موبایل</p>
</td>
<td width="292">
<p>به کلاس OnSiteOrderService تابع phoneOrderRegister جهت ورود با موبایل اضافه گردید</p>
</td>
</tr>

<tr>
<td width="64">
<p><strong>۷</strong></p>
</td>
<td width="198">
<p>OnSiteOrderService</p>
</td>
<td width="141">
<p>افزودن واسط پرداخت با موبایل</p>
</td>
<td width="292">
<p>به کلاس OnSiteOrderService تابع phoneOrderPayment جهت پرداخت با موبایل اضافه گردید</p>
</td>
</tr>

<tr>
<td width="64">
<p><strong>۸</strong></p>
</td>
<td width="198">
<p>Main</p>
</td>
<td width="141">
<p>انتخاب روش پرداخت با موبایل</p>
</td>
<td width="292">
<p>با افزودن یک else if دیگر به بخش //step2 تعیین گردید که اگر مشتری عدد ۳ را برای روش پرداخت وارد کرد، پرداخت از طریق موبایل برای او در نظر گرفته شودو در اطلاعات سفارش ثبت گردد</p>
</td>
</tr>

<tr>
<td width="64">
<p><strong>۹</strong></p>
</td>
<td width="198">
<p>Main</p>
</td>
<td width="141">
<p>پرداخت با موبایل</p>
</td>
<td width="292">
<p>در بخش //step3 برای پرداخت یک گزینه else if اضافه گردید که اگر روش پرداخت با موبایل در صورت حساب ذکر شده بود، پرداخت از ؤآن طریق انجام گیرد.</p>
</td>
</tr>

</tbody>
</table>

مجموع تعداد تغییرات: ۹

### گام ۲: تحلیل و وارسی برنامه از منظر تحقق و یا عدم تحقق اصول SOLID
در خصوص این برنامه‌ای که نوشته شده بود و شما یک قابلیت به آن اضافه کردید، بر اساس اصول SOLID موارد نقض و یا محقق شدن هر کدام از آن اصول را بیان کنید. در بیان موارد تحقق و نقض، علت تحقق و یا نقض را نیز به صورت کامل توضیح دهید:

<table dir='rtl'>
<tbody>
<tr>
<td rowspan="2" width="240">
<p>اصل 1</p>
<p>Single Responsibility</p>
</td>
<td width="95">
<p><strong>موارد تحقق</strong></p>
</td>
<td width="454">
<p>کلاس Food تنها شامل ویژگی‌ها و عمل‌های مربوط به اسم غذا و قیمت آن است.</p>
</td>
</tr>
<tr>
<td>
<p><strong>موارد نقض</strong></p>
</td>
<td>
<p>کلاس Order هم کار ثبت غذا را انجام میدهد و هم کار مربوط به حساب کردن قیمت غذا را انجام می‌دهد. همچنین کلاس‌های orderService هم کار مربوظ بهع 
 ثبت روش خرید را انجام می‌دهند و هم کار مربوط به ثبت قیمت سفارش را انجام می‌دهند. در نتیجه این دو کلاس تک‌وظیفه‌ای نیستند.</p>
</td>
</tr>
<tr>
<td rowspan="2">
<p>اصل 2</p>
<p>Open-Close Principle (OCP)</p>
</td>
<td>
<p><strong>موارد تحقق</strong></p>
</td>
<td>
<p>در کد فایل Main برای اضافه کردن پرداخت تلفنی نیاز به اعمال تغییرات زیاد در منطق کد این بخش نبود.</p>
</td>
</tr>
<tr>
<td>
<p><strong>موارد نقض</strong></p>
</td>
<td>
<p>هرچند، برای اضافه کردن نیازمندی پرداخت تلفنی، متود‌های مربوط به تمام  کلاس‌های OrderService به خاطر وراثت باید متود‌های مربوط به پرداخت تلفنی را داشته باشند (بدنه متود خالی باشد) که این خود تغییرات زیادی رادر کد می‌طلبد.</p>
</td>
</tr>
<tr>
<td rowspan="2">
<p>اصل 3</p>
<p>Liskov Substitution Principle</p>
</td>
<td>
<p><strong>موارد تحقق</strong></p>
</td>
<td>
<p>میان کلاس orderService و تمام کلاس‌های OrderService مربوط به روش‌های پرداخت متفاوت به خاطر وراثت رابطه is-a وجود دارد. و هرکدام از آنها در کد به ‌جای کلاس والد می‌تواند کار کند (باتوجه به سازگاری متودهایشان)</p>
</td>
</tr>
<tr>
<td>
<p><strong>موارد نقض</strong></p>
</td>
<td>
<p></p>
</td>
</tr>
<tr>
<td rowspan="2">
<p>اصل 4</p>
<p>Interface Segregation Principle</p>
</td>
<td>
<p><strong>موارد تحقق</strong></p>
</td>
<td>
<p>&nbsp;</p>
</td>
</tr>
<tr>
<td>
<p><strong>موارد نقض</strong></p>
</td>
<td>
<p>کلاس OrderService شامل تمام متود‌ها برای انواع روش‌های پرداخت است. این باعث می‌شود که در کلاس مربوط به روش‌های پرداخت متفاوت تعداد زیادی متود با بدنه خالی که مربوط به روش‌های پرداخت دیگر است، وجود داشته باشد.</p>
</td>
</tr>
<tr>
<td rowspan="2">
<p>اصل 5</p>
<p>Dependency Inversion Principle</p>
</td>
<td>
<p><strong>موارد تحقق</strong></p>
</td>
<td>
<p>متود کلاس‌های روش گرداخت به صورت کلی بر پایه متود‌های کلاس واسط OrderService می‌باشند.</p>
</td>
</tr>
<tr>
<td>
<p><strong>موارد نقض</strong></p>
</td>
<td>
<p>با این حال، در کد Main همجنان نیاز به این وجود دارد که نوع اصلی کلاس‌های روش پرداخت مشخص شوند. به عبارت دیگر، در کد Main نیاز به دسترسی به اشیا اصلی مربوط به روش‌های پرداخت وجود دارد و هیچ ارتباطی بر پایه کلاس‌های واسط در اینجا برقرار نیست.</p>
</td>
</tr>
</tbody>
</table>

در خصوص هرکدام از موارد نقض هرکدام از اصول، یک راهکار را به منظور رفع آن مشکل ارایه داده و در جدول زیر ثبت نمایید:

<table dir='rtl'>
<tbody>
<tr>
<td width="168">
<p><strong>اصل مربوطه (از اصول </strong><strong>SOLID</strong><strong>)</strong></p>
</td>
<td width="246">
<p><strong>علت نقض</strong></p>
</td>
<td width="284">
<p><strong>راه حل پیشنهادی</strong></p>
</td>
</tr>
<tr>
<td width="168">
<p>اصل SRP</p>
</td>
<td width="246">
<p>وجود چندین وظیفه در کلاس‌های order و OrderService</p>
</td>
<td width="284">
<p>در کلاس OrderService ثبت سفارش و ثبت قیمت آن باید در کلاس‌های جداگانه  اتجام شود و به طور مشابه برای کلاس Order ثبت غذا سفارش و محاسبه قیمت کل غذا به صورت جداانجام شود (هرچند اعمال این روش در اینجا باعث ایجاد کلاس‌های متعدد می‌شود که باعث شلوغ شدن کد خواهد شد) </p>
</td>
</tr>
<tr>
<td width="168">
<p>اصل OCP</p>
</td>
<td width="246">
<p>ایجاد تغییرات در متود‌های کلاس مربوط به روش‌های پرداخت</p>
</td>
<td width="284">
<p>باتوجه به اینکه هر کلاس روش پرداخت تنها دو کار ثبت سفارش و ثبت قیمت را انجام می‌دهد، در کلاس واسط OrderService میتوان تنها دو متود مربوط به این کار را قرار داد و این متود‌ها را در کلاس‌های مربوط به هر روش پرداخت بازنویسی کرد و نیاز به ایجاد متود ثبت سفارش و قیمت خاص برای هر روش پرداخت نیست.</p>
</td>
</tr>
<tr>
<td width="168">
<p>اصل ISP</p>
</td>
<td width="246">
<p>وجود تعداد زیاد متود‌ها در کلاس واسط OrderService که باعث ایجاد میراث مردود در کلاس مربوط به بقیه روش‌های پرداخت می‌شود.</p>
</td>
<td width="284">
<p>راه‌حل برای رفع مشکل OCP ، مشکل را در اینجا نیز حل می‌کند.</p>
</td>
</tr>
<tr>
<td width="168">
<p>اصل DIP</p>
</td>
<td width="246">
<p>نیاز به دسترسی مستقیم به اشیا مربوط به روش‌های پرداخت و وجود نداشتن ارتباط با استفاده از واسط در اینجا</p>
</td>
<td width="284">
<p>برای ایجاد ارتباط بر پایه کلاس واسط میتوان از الگو طراحی کارخانه (factory method) استفاده کرد تا این وابستگی بر نوع روش پرداخت از بین برود.</p>
</td>
</tr>
</tbody>
</table>

### گام ۳: اصلاح موارد نقض
در نهایت، بر اساس تحلیلی که انجام داده‌اید و راه حل‌هایی که در بخش قبل ارایه کردید، کد را اصلاح کرده و بر روی مخزن گیت‌هاب و در پوشه‌ای مجزا از گام قبل commit و push کنید. انتظار می‌رود که تمامی راه حل‌های پیشنهادی خود را بر روی این نسخه اعمال کنید و تمامی بهبودهایی که انجام می‌دهید، در جداول بخش قبل موجود باشد.

### گام ۴: بررسی مجدد تغییرات مورد نیاز
فرض کنید که گام 1 را برای کد اصلاح شده (پس از انجام گام‌های ۲ و ۳) اجرا کرده‌اید.
1. در این صورت از انجام کدام یک از تغییرات ثبت شده در جدول گام ۱ معاف خواهید شد؟
2. تعداد تغییرات مورد نیاز، چند تغییر خواهد شد؟

پاسخ:

با به‌کار گیری اصول SOLID همانطور که از نتایج مشخص است، برای ایجاد یک ویژگی جدید به کد دیگر احتیاج به ایجاد تغییرات بسیار زیاد در کد نبود و در کد اصلاح‌شده تنها با ایجاد کمترین تغییرات می‌توان ویژگی‌‌های جدید به کد اضافه کرد. این ویژگی  برای قابلیت نگه‌داری سیستم‌های نرم‌افزاری و حفظ قابلیت آنها برای تغییر کردن در طول زمان برای جواب دادن به نیازمندی‌های جدید بسیار با‌اهمیت است.

### گام ۵: جمع بندی
در این بخش، بیان کنید که از این گام چه نتیجه‌ای گرفته‌اید؟ و به نظر شما به کارگیری صحیح اصول SOLID در گام‌های ۳ و ۴ چه مزایایی را نسبت به حالتی دارد که این اصول رعایت نشده‌بود؟

## نحوه ارسال پروژه:
1.	گام ۱ را انجام داده و سپس کد نوشته شده‌ی خود را (با رعایت محدودیت‌های گفته شده در گام) در یک پوشه به نام Step_1_Non_SOLID ذخیره کنید و در مخزن گام ۲ قرار دهید. موارد توضیحی بایستی در بخش README مخزن قرار گیرد.
2.	گام ۲ (که بخش تحلیلی است) در فایل README مربوط به مخزن گام ۲ آورده شود (تمام جداول با فرمت داده شده و عناوین هرکدام از سوالات پرسیده شده بایستی در README آورده شود).
3.	گام ۳ که شامل بهبود است، بایستی به صورت جداگانه در پوشه دیگری به نام Step_3_With_SOLID قرار داده شود و در مخزن موجود باشد.
4.	گام ۴ نیز در قالب توضیحات در README مخزن آورده شود.
5.	گام ۵ (که نتیجه گیری است) در README مخزن آورده شود.
